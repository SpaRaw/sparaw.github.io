<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üßµ Grid Overlay Tool f√ºr Kreuzstich</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #4a5568;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .header p {
            color: #718096;
            font-size: 1.1em;
        }

        .controls-section {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .controls-row {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            min-width: 150px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
        }

        .btn-info {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .slider-control {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 10px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            min-width: 200px;
        }

        .slider-control label {
            color: #4a5568;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .slider-control input[type="range"] {
            width: 180px;
            margin: 5px 0;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-control input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider-value {
            color: #667eea;
            font-weight: bold;
            font-size: 16px;
            margin-top: 5px;
        }

        .image-section {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        .image-container {
            position: relative;
            display: inline-block;
            border: 3px solid #4a5568;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            background: #fff;
        }

        .original-image {
            display: block;
            width: 600px;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .info-section {
            background: #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            text-align: center;
        }

        .info-section h3 {
            color: #4a5568;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .info-section p {
            color: #718096;
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #718096;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .loading {
            text-align: center;
            color: #4a5568;
            font-size: 1.1em;
            margin: 20px 0;
        }

        .loading::after {
            content: '';
            animation: dots 1.5s steps(5, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
            80%, 100% { content: '....'; }
        }

        .palette {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .color-swatch {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            font-size: 0.9em;
        }

        .swatch-box {
            width: 22px;
            height: 22px;
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.08);
        }

        @media (max-width: 768px) {
            .original-image {
                width: 100%;
                max-width: 400px;
            }
            
            .controls-section {
                flex-direction: column;
                align-items: center;
            }
            
            .slider-control {
                min-width: 100%;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üßµ Grid Overlay Tool f√ºr Kreuzstich</h1>
            <p>Legen Sie ein pr√§zises Grid √ºber Ihr Bild f√ºr perfekte Kreuzstich-Vorlagen</p>
        </div>

        <div class="controls-section">
            <div class="controls-row">
                <input type="file" id="fileInput" accept="image/*" onchange="handleImageUpload(event)">
                <button class="btn btn-primary" onclick="loadImageFile()">
                    üìÅ Bild laden
                </button>
                <button class="btn btn-secondary" onclick="toggleGrid(this)">
                    üìê Grid ein/aus
                </button>
                <button class="btn btn-warning" id="wakeLockBtn" onclick="toggleWakeLock()">
                    üîÜ Bildschirm an lassen
                </button>
            </div>
            
            <div class="controls-row">
                <div class="slider-control">
                    <label>üî≤ Grid-Gr√∂√üe (Pixel)</label>
                    <input type="range" id="gridSizeSlider" min="1" max="50" value="10" oninput="updateGridSize(this.value)">
                    <div class="slider-value">
                        <span id="gridSizeValue">10</span> Pixel
                    </div>
                    <div style="margin-top:8px;">
                        <button class="btn btn-info" onclick="autoDetectPixelSize()">üß† Auto-Detect</button>
                    </div>
                </div>
                
                <div class="slider-control">
                    <label>üì¶ Box-Gr√∂√üe</label>
                    <input type="range" id="boxSizeSlider" min="1" max="50" value="10" oninput="updateBoxSize(this.value)">
                    <div class="slider-value">
                        <span id="boxSizeValue">10</span> x <span id="boxSizeValue2">10</span>
                    </div>
                </div>
            </div>
            
            <div class="controls-row">
                <button class="btn btn-info" onclick="changeGridSize(-1)">üîç- Feiner</button>
                <button class="btn btn-info" onclick="changeGridSize(1)">üîç+ Gr√∂ber</button>
                <button class="btn btn-success" onclick="saveImage()">üíæ Bild speichern</button>
            </div>
        </div>

        <div class="image-section">
            <div class="image-container" id="imageContainer">
                <canvas id="originalCanvas" class="original-image"></canvas>
                <canvas id="gridCanvas" class="grid-overlay"></canvas>
            </div>
        </div>

        <div class="info-section">
            <h3>üìä Bild-Statistiken</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="imageWidth">-</div>
                    <div class="stat-label">Breite (Pixel)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="imageHeight">-</div>
                    <div class="stat-label">H√∂he (Pixel)</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="gridColumns">-</div>
                    <div class="stat-label">Grid Spalten</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="gridRows">-</div>
                    <div class="stat-label">Grid Zeilen</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="boxColumns">-</div>
                    <div class="stat-label">Box Spalten</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="boxRows">-</div>
                    <div class="stat-label">Box Zeilen</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="detectedPixelSize">-</div>
                    <div class="stat-label">Erkannte Pixelgr√∂√üe</div>
                </div>
            </div>
            
            <p><strong>üí° Tipp:</strong> Das originale Bild bleibt unver√§ndert. Nur das schwarze Grid wird dar√ºber gelegt.</p>
            <p><strong>üìê Grid:</strong> Feine Linien f√ºr einzelne Stiche | <strong>üì¶ Boxen:</strong> Dicke Linien f√ºr Bereiche</p>

            <h3 style="margin-top:18px">üé® Verwendete Farben</h3>
            <div id="palette" class="palette">
                <!-- Farbfelder werden hier eingef√ºgt -->
            </div>
        </div>
    </div>

    <script>
        let gridSize = 10;
        let boxSize = 10;
        let gridVisible = true;
        let originalImage = null;
        let wakeLock = null;

        const originalCanvas = document.getElementById('originalCanvas');
        const gridCanvas = document.getElementById('gridCanvas');
        const originalCtx = originalCanvas.getContext('2d');
        const gridCtx = gridCanvas.getContext('2d');

        // --- Helper: convert RGBA to hex (ignore fully transparent pixels) ---
        function rgbaToHex(r, g, b, a) {
            if (a === 0) return null;
            const toHex = (n) => ('0' + n.toString(16)).slice(-2).toUpperCase();
            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        // --- Create placeholder image when nothing loaded ---
        function createPlaceholderImage() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 600;
            canvas.height = 400;
            
            const gradient = ctx.createLinearGradient(0, 0, 600, 400);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(0.3, '#87CEEB');
            gradient.addColorStop(0.7, '#ADD8E6');
            gradient.addColorStop(1, '#764ba2');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 600, 400);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 600;
                const y = Math.random() * 400;
                const size = Math.random() * 30 + 10;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 4;
            ctx.fillText('üßµ Laden Sie Ihr Kreuzstich-Bild hoch', 300, 180);
            
            ctx.font = '18px Arial';
            ctx.fillText('um das pr√§zise Grid zu sehen', 300, 220);
            
            return canvas.toDataURL();
        }

        function initializeCanvas() {
            if (!originalImage) {
                const img = new Image();
                img.onload = function() {
                    setupCanvases(this);
                    // Auto-detect pixel size for placeholder not necessary, keep default
                    drawGrid();
                    updateStats();
                    computeAndShowPalette();
                };
                img.src = createPlaceholderImage();
            }
        }

        function setupCanvases(img) {
            // Set canvas internal pixel size to image natural resolution
            originalCanvas.width = img.width;
            originalCanvas.height = img.height;
            // Display size (CSS) to fit container but preserve pixelated rendering
            const containerWidth = Math.min(600, window.innerWidth - 100);
            const aspectRatio = img.height / img.width;
            const containerHeight = containerWidth * aspectRatio;
            originalCanvas.style.width = containerWidth + 'px';
            originalCanvas.style.height = containerHeight + 'px';
            originalCtx.imageSmoothingEnabled = false;
            originalCtx.clearRect(0, 0, originalCanvas.width, originalCanvas.height);
            originalCtx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);

            // Grid canvas
            gridCanvas.width = img.width;
            gridCanvas.height = img.height;
            gridCanvas.style.width = containerWidth + 'px';
            gridCanvas.style.height = containerHeight + 'px';
            gridCtx.imageSmoothingEnabled = false;
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            originalImage = img;
        }

        // --- Pixelgr√∂√üe erkennen (Modus der Farbl√§ngen in X und Y) ---
        function detectPixelSize() {
            if (!originalImage) return 1;
            const w = originalCanvas.width;
            const h = originalCanvas.height;
            // Safeguard for tiny images
            if (w <= 1 || h <= 1) return 1;

            const imgData = originalCtx.getImageData(0, 0, w, h).data;
            const runs = [];

            // Sample einige Zeilen (gleichm√§√üig verteilt)
            const sampleRows = Math.min(40, h);
            const rowStep = Math.max(1, Math.floor(h / sampleRows));

            for (let sy = 0; sy < h; sy += rowStep) {
                let lastColor = null;
                let runLen = 0;
                for (let x = 0; x < w; x++) {
                    const idx = (sy * w + x) * 4;
                    const hex = rgbaToHex(imgData[idx], imgData[idx+1], imgData[idx+2], imgData[idx+3]);
                    // Transparent pixels: treat as unique marker to avoid merging runs across transparency
                    const color = hex === null ? 'TRANSPARENT' : hex;
                    if (lastColor === null) {
                        lastColor = color;
                        runLen = 1;
                    } else if (color === lastColor) {
                        runLen++;
                    } else {
                        // push runLen (ignore runs of length 0)
                        if (runLen > 0) runs.push(runLen);
                        lastColor = color;
                        runLen = 1;
                    }
                }
                if (runLen > 0) runs.push(runLen);
            }

            // Sample Spalten (vertikal) um X-Ergebnis abzugleichen
            const runsV = [];
            const sampleCols = Math.min(40, w);
            const colStep = Math.max(1, Math.floor(w / sampleCols));
            for (let sx = 0; sx < w; sx += colStep) {
                let lastColor = null;
                let runLen = 0;
                for (let y = 0; y < h; y++) {
                    const idx = (y * w + sx) * 4;
                    const hex = rgbaToHex(imgData[idx], imgData[idx+1], imgData[idx+2], imgData[idx+3]);
                    const color = hex === null ? 'TRANSPARENT' : hex;
                    if (lastColor === null) {
                        lastColor = color;
                        runLen = 1;
                    } else if (color === lastColor) {
                        runLen++;
                    } else {
                        if (runLen > 0) runsV.push(runLen);
                        lastColor = color;
                        runLen = 1;
                    }
                }
                if (runLen > 0) runsV.push(runLen);
            }

            function modeOfSmallRuns(arr) {
                // Filter extremely large runs that might be background stretches; focus on <= 200
                const filtered = arr.filter(n => n >= 1 && n <= 200);
                if (filtered.length === 0) return 1;
                const freq = {};
                for (const n of filtered) freq[n] = (freq[n] || 0) + 1;
                let best = filtered[0], bestCount = 0;
                for (const k in freq) {
                    const v = freq[k];
                    if (v > bestCount) { bestCount = v; best = parseInt(k); }
                }
                return best;
            }

            const modeX = modeOfSmallRuns(runs);
            const modeY = modeOfSmallRuns(runsV);
            // Take the smaller of both (robuster gegen streckungen), but at least 1 and cap to 50
            const detected = Math.max(1, Math.min(50, Math.round((modeX + modeY) / 2)));
            return detected;
        }

        // --- Palette aus Bild berechnen und anzeigen ---
        function computeAndShowPalette() {
            const paletteEl = document.getElementById('palette');
            paletteEl.innerHTML = '';
            if (!originalImage) return;

            const w = originalCanvas.width;
            const h = originalCanvas.height;
            const imgData = originalCtx.getImageData(0, 0, w, h).data;
            const counts = Object.create(null);

            for (let i = 0; i < imgData.length; i += 4) {
                const a = imgData[i+3];
                if (a === 0) continue; // skip transparent
                const hex = rgbaToHex(imgData[i], imgData[i+1], imgData[i+2], a);
                if (!hex) continue;
                counts[hex] = (counts[hex] || 0) + 1;
            }

            // Sort by usage descending
            const entries = Object.entries(counts).sort((a,b) => b[1] - a[1]);

            // Erstelle Anzeige (Swatches + Count)
            for (const [hex, count] of entries) {
                const sw = document.createElement('div');
                sw.className = 'color-swatch';
                const box = document.createElement('div');
                box.className = 'swatch-box';
                box.style.background = hex;
                const label = document.createElement('div');
                label.textContent = `${hex} (${count})`;
                sw.appendChild(box);
                sw.appendChild(label);
                paletteEl.appendChild(sw);
            }
        }

        // --- Grid zeichnen: exakt auf Pixelgr√∂√üe (gridSize) und nur innerhalb Bildgrenzen ---
        function drawGrid() {
            if (!originalImage) return;

            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            if (!gridVisible) return;

            // feine Grid-Linien
            gridCtx.save();
            gridCtx.strokeStyle = '#000000';
            gridCtx.lineWidth = 1;
            gridCtx.globalAlpha = 0.6;

            // Verticals
            for (let x = 0; x <= gridCanvas.width; x += gridSize) {
                // Stelle sicher dass Linie innerhalb des Bildbereichs liegt (0..width)
                if (x < 0 || x > gridCanvas.width) continue;
                gridCtx.beginPath();
                gridCtx.moveTo(x + 0.5, 0); // 0.5 f√ºr sch√§rfere 1px Linien
                gridCtx.lineTo(x + 0.5, gridCanvas.height);
                gridCtx.stroke();
            }

            // Horizontals
            for (let y = 0; y <= gridCanvas.height; y += gridSize) {
                if (y < 0 || y > gridCanvas.height) continue;
                gridCtx.beginPath();
                gridCtx.moveTo(0, y + 0.5);
                gridCtx.lineTo(gridCanvas.width, y + 0.5);
                gridCtx.stroke();
            }

            // dickere Box-Linien (jede boxSize * gridSize)
            gridCtx.strokeStyle = '#000000';
            gridCtx.lineWidth = 3;
            gridCtx.globalAlpha = 0.9;

            const boxPixelSize = Math.max(1, boxSize * gridSize);

            for (let x = 0; x <= gridCanvas.width; x += boxPixelSize) {
                if (x < 0 || x > gridCanvas.width) continue;
                gridCtx.beginPath();
                gridCtx.moveTo(x + 1.5, 0);
                gridCtx.lineTo(x + 1.5, gridCanvas.height);
                gridCtx.stroke();
            }

            for (let y = 0; y <= gridCanvas.height; y += boxPixelSize) {
                if (y < 0 || y > gridCanvas.height) continue;
                gridCtx.beginPath();
                gridCtx.moveTo(0, y + 1.5);
                gridCtx.lineTo(gridCanvas.width, y + 1.5);
                gridCtx.stroke();
            }

            gridCtx.restore();
        }

        function toggleGrid(btnEl) {
            gridVisible = !gridVisible;
            btnEl.textContent = gridVisible ? 'üìê Grid ein/aus' : 'üìê Grid aktivieren';
            btnEl.style.background = gridVisible ? 
                'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)' : 
                'linear-gradient(135deg, #10b981 0%, #059669 100%)';
            drawGrid();
        }

        function changeGridSize(delta) {
            gridSize = Math.max(1, Math.min(50, gridSize + delta));
            document.getElementById('gridSizeSlider').value = gridSize;
            document.getElementById('gridSizeValue').textContent = gridSize;
            drawGrid();
            updateStats();
        }

        function updateGridSize(value) {
            gridSize = parseInt(value);
            document.getElementById('gridSizeValue').textContent = gridSize;
            drawGrid();
            updateStats();
        }

        function updateBoxSize(value) {
            boxSize = parseInt(value);
            document.getElementById('boxSizeValue').textContent = boxSize;
            document.getElementById('boxSizeValue2').textContent = boxSize;
            drawGrid();
            updateStats();
        }

        function loadImageFile() {
            document.getElementById('fileInput').click();
        }

        function handleImageUpload(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    setupCanvases(this);

                    // auto-detect pixel size nach dem Rendern
                    const detected = detectPixelSize();
                    gridSize = detected;
                    document.getElementById('gridSizeSlider').value = gridSize;
                    document.getElementById('gridSizeValue').textContent = gridSize;
                    document.getElementById('detectedPixelSize').textContent = gridSize;

                    // Palette berechnen & rendern
                    computeAndShowPalette();

                    drawGrid();
                    updateStats();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Manuelle Auto-Detect Schaltfl√§che
        function autoDetectPixelSize() {
            if (!originalImage) {
                alert('Bitte zuerst ein Bild laden.');
                return;
            }
            const detected = detectPixelSize();
            gridSize = detected;
            document.getElementById('gridSizeSlider').value = gridSize;
            document.getElementById('gridSizeValue').textContent = gridSize;
            document.getElementById('detectedPixelSize').textContent = gridSize;
            drawGrid();
            updateStats();
        }

        function saveImage() {
            if (!originalImage) {
                alert('Bitte laden Sie zuerst ein Bild hoch!');
                return;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = originalCanvas.width;
            tempCanvas.height = originalCanvas.height;
            
            // Originalbild
            tempCtx.drawImage(originalCanvas, 0, 0);
            // Grid (bereits in selben Pixel-Koordinatensystem)
            tempCtx.drawImage(gridCanvas, 0, 0);
            
            const link = document.createElement('a');
            link.download = 'kreuzstich-grid-vorlage.png';
            link.href = tempCanvas.toDataURL();
            link.click();
        }

        async function toggleWakeLock() {
            const btn = document.getElementById('wakeLockBtn');
            
            if (!('wakeLock' in navigator)) {
                alert('Wake Lock wird von diesem Browser nicht unterst√ºtzt');
                return;
            }

            try {
                if (wakeLock === null) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    btn.textContent = 'üîÜ Bildschirm aktiv';
                    btn.style.background = 'linear-gradient(135deg, #10b981 0%, #059669 100%)';
                    
                    wakeLock.addEventListener('release', () => {
                        btn.textContent = 'üîÜ Bildschirm an lassen';
                        btn.style.background = 'linear-gradient(135deg, #f59e0b 0%, #d97706 100%)';
                        wakeLock = null;
                    });
                } else {
                    wakeLock.release();
                    wakeLock = null;
                }
            } catch (err) {
                console.error('Wake Lock Fehler:', err);
                alert('Bildschirm Wake Lock konnte nicht aktiviert werden');
            }
        }

        function updateStats() {
            if (!originalImage) {
                document.getElementById('imageWidth').textContent = '-';
                document.getElementById('imageHeight').textContent = '-';
                document.getElementById('gridColumns').textContent = '-';
                document.getElementById('gridRows').textContent = '-';
                document.getElementById('boxColumns').textContent = '-';
                document.getElementById('boxRows').textContent = '-';
                document.getElementById('detectedPixelSize').textContent = '-';
                return;
            }

            const width = originalCanvas.width;
            const height = originalCanvas.height;
            const columns = Math.ceil(width / gridSize);
            const rows = Math.ceil(height / gridSize);
            const boxColumns = Math.ceil(columns / boxSize);
            const boxRows = Math.ceil(rows / boxSize);

            document.getElementById('imageWidth').textContent = width;
            document.getElementById('imageHeight').textContent = height;
            document.getElementById('gridColumns').textContent = columns;
            document.getElementById('gridRows').textContent = rows;
            document.getElementById('boxColumns').textContent = boxColumns;
            document.getElementById('boxRows').textContent = boxRows;
            document.getElementById('detectedPixelSize').textContent = gridSize;
        }

        // Initialisiere beim Laden der Seite
        initializeCanvas();

        // Cleanup beim Schlie√üen der Seite
        window.addEventListener('beforeunload', () => {
            if (wakeLock !== null) {
                wakeLock.release();
            }
        });

        // Responsiv: Beim Resize die CSS-Gr√∂√üe anpassen, Canvas intern bleibt gleich
        window.addEventListener('resize', () => {
            if (!originalImage) return;
            const containerWidth = Math.min(600, window.innerWidth - 100);
            const aspectRatio = originalCanvas.height / originalCanvas.width;
            const containerHeight = containerWidth * aspectRatio;
            originalCanvas.style.width = containerWidth + 'px';
            originalCanvas.style.height = containerHeight + 'px';
            gridCanvas.style.width = containerWidth + 'px';
            gridCanvas.style.height = containerHeight + 'px';
        });
    </script>
</body>
</html>
